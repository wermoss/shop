import { defineEventHandler, readBody, readRawBody, getHeader } from "h3";
import Stripe from "stripe";

interface ProductDetail {
  id: number;
  qty: number;
}

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig();
  const stripe = new Stripe(config.stripeSecretKey, {
    apiVersion: "2025-05-28.basil",
  });

  console.log("üîî [Webhook] Endpoint hit");

  const signature = getHeader(event, "stripe-signature");
  const rawBody = await readRawBody(event);

  // Sprawdzamy ≈∫r√≥d≈Ço webhooka (StripeCD lub rzeczywisty)
  const webhookSource = getHeader(event, "user-agent") || "";
  const isStripeCLI = webhookSource.toLowerCase().includes("stripecli");

  console.log(
    `üîç [Webhook] Source: ${
      isStripeCLI ? "Stripe CLI (local)" : "Stripe (production)"
    }`
  );

  if (!signature || !rawBody) {
    console.error("‚ùå [Webhook] No signature or body found");
    throw createError({
      statusCode: 400,
      message: "Missing signature or body",
    });
  }

  let stripeEvent;

  try {
    stripeEvent = stripe.webhooks.constructEvent(
      rawBody,
      signature,
      config.stripeWebhookSecret
    );
    console.log(
      `‚úÖ [Webhook] Event verified successfully: ${stripeEvent.type} from ${
        isStripeCLI ? "CLI" : "production"
      }`
    );
  } catch (err) {
    console.error("‚ùå [Webhook] Signature verification failed:", err);
    throw createError({
      statusCode: 400,
      message: "Webhook signature verification failed",
    });
  }

  // Handle stripe events
  const session = stripeEvent.data.object as Stripe.Checkout.Session;

  // Only handle successful payments
  if (
    stripeEvent.type === "checkout.session.completed" &&
    session.payment_status === "paid"
  ) {
    console.log("üí∞ [Webhook] Processing completed checkout session:", {
      sessionId: session.id,
      orderNumber: session.metadata?.orderNumber,
      source: isStripeCLI ? "CLI" : "production",
    });

    // Sprawd≈∫ czy mail ju≈º zosta≈Ç wys≈Çany (niezale≈ºnie od ≈∫r√≥d≈Ça webhooka)
    if (session.metadata?.emailSent === "true") {
      console.log(
        `üìß [Webhook] Email already sent for this session (source: ${
          isStripeCLI ? "CLI" : "production"
        })`
      );
      return { success: true, status: "already_processed" };
    }

    try {
      if (!session.metadata?.productIds) {
        throw createError({
          statusCode: 400,
          message: "No product information in session",
        });
      }

      // Get product details
      console.log("üì¶ [Webhook] Processing order products");
      const productsData = await import("../../../data/products.json");
      const productDetails = JSON.parse(
        session.metadata.productIds
      ) as ProductDetail[];

      if (!Array.isArray(productDetails)) {
        throw createError({
          statusCode: 400,
          message: "Invalid product details format",
        });
      }

      // Calculate totals exactly as in cart-notification
      let subtotalAmount = 0;
      const cartDiscount = parseInt(session.metadata?.cartDiscount || "0");
      const codeDiscount = parseInt(session.metadata?.codeDiscount || "0");
      const totalDiscount = cartDiscount + codeDiscount;

      // Map products with prices (bez formatowania!)
      const emailProducts = [];

      // Najpierw oblicz subtotalAmount przez dodanie cen wszystkich produkt√≥w
      for (const item of productDetails) {
        const product = productsData.products.find((p) => p.id === item.id);
        if (!product) {
          throw createError({
            statusCode: 500,
            message: `Product not found: ${item.id}`,
          });
        }

        // Oblicz warto≈õci bez ≈ºadnego zaokrƒÖglania
        const unitPrice = product.price;
        subtotalAmount += unitPrice * item.qty;

        // Przeka≈º surowe warto≈õci do order-confirmation
        emailProducts.push({
          name: product.name,
          quantity: item.qty,
          unitPrice: unitPrice, // cena bez rabatu
          totalPrice: unitPrice * item.qty, // cena * ilo≈õƒá bez rabatu
        });
      }

      // Obliczanie rabatu i kwot - dok≈Çadnie jak w cart-notification.post.ts
      // Oblicz rabat po wyliczeniu sumy (wa≈ºne dla sp√≥jno≈õci)
      const discountAmount = subtotalAmount * (totalDiscount / 100);
      // ZaokrƒÖglij finalAmount tak samo jak w create-session.post.ts
      const finalAmount =
        Math.round((subtotalAmount - discountAmount) * 100) / 100;

      console.log("üí∞ [Webhook] Order totals:", {
        subtotalAmount: subtotalAmount,
        discountAmount: discountAmount,
        finalAmount: finalAmount,
        totalDiscount: totalDiscount,
        calculationCheck: {
          discount: (subtotalAmount * (totalDiscount / 100)).toFixed(2),
          final: (subtotalAmount - discountAmount).toFixed(2),
          finalRounded:
            Math.round((subtotalAmount - discountAmount) * 100) / 100,
          originalMetadata: {
            subtotal: session.metadata?.subtotalAmount,
            discount: session.metadata?.discountAmount,
            total: session.metadata?.totalAmount,
          },
        },
      });

      // Send confirmation email
      const emailResponse = await $fetch("/api/mail/order-confirmation", {
        method: "POST",
        body: {
          customerEmail: session.metadata?.customerEmail,
          orderDetails: {
            orderNumber: session.metadata?.orderNumber,
            customerName: session.metadata?.customerName,
            customerEmail: session.metadata?.customerEmail,
            customerPhone: session.metadata?.customerPhone,
            shippingAddress: {
              street: session.metadata?.shippingStreet,
              houseNumber: session.metadata?.shippingHouseNumber,
              postalCode: session.metadata?.shippingPostalCode,
              city: session.metadata?.shippingCity,
              country: session.metadata?.shippingCountry,
            },
            subtotalAmount,
            discountAmount,
            amount: finalAmount,
            items: emailProducts,
            cartDiscount,
            codeDiscount,
            discountCode: session.metadata?.discountCode || "",
            totalDiscount,
          },
        },
      });

      if (!emailResponse.success) {
        throw new Error("Failed to send order confirmation email");
      }

      // Zawsze oznacz sesjƒô jako obs≈Çu≈ºonƒÖ, niezale≈ºnie od ≈∫r√≥d≈Ça webhooka
      await stripe.checkout.sessions.update(session.id, {
        metadata: { ...session.metadata, emailSent: "true" },
      });
      console.log(
        `‚úÖ [Webhook] Session marked as processed (source: ${
          isStripeCLI ? "CLI" : "production"
        })`
      );

      return {
        success: true,
        status: "processed",
        source: isStripeCLI ? "cli" : "production",
      };
    } catch (error) {
      console.error("‚ùå [Webhook] Order processing failed:", error);
      throw createError({
        statusCode: 500,
        message:
          error instanceof Error ? error.message : "Order processing failed",
      });
    }
  }

  // For other events just acknowledge receipt
  return {
    received: true,
    type: stripeEvent.type,
    status: "unhandled",
    source: isStripeCLI ? "cli" : "production",
  };
});
