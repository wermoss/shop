import { defineEventHandler, readBody, readRawBody, getHeader } from "h3";
import Stripe from "stripe";
import type { Product } from "~/types/shop";

// Oryginalny format szczegółów produktu
interface ProductDetail {
  id: number;
  name: string;
  price: number;
  quantity: number;
  lineItemTotalPrice: number;
  discountAppliedToLineItem: number;
  lineItemTotalPriceWithDiscount: number;
  image?: string;
}

// Skompresowany f            console.log(
              `🔔 [Webhook] Influencer notification result:`,
              JSON.stringify(influencerNotificationResult, null, 2)
            );

            if (!influencerNotificationResult.success) {
              console.error(
                `❌ [Webhook] Failed to send influencer notification:`,
                JSON.stringify(influencerNotificationResult, null, 2)
              );egółów produktu używany do oszczędzania miejsca w metadanych Stripe
interface CompressedProductDetail {
  id: number;
  n: string; // skrócona nazwa (name)
  p: number; // cena (price)
  q: number; // ilość (quantity)
  d: number; // rabat (discountAppliedToLineItem)
  f: number; // ostateczna cena (lineItemTotalPriceWithDiscount)
}

export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig();
  const stripe = new Stripe(config.stripeSecretKey, {
    apiVersion: "2025-05-28.basil",
  });

  console.log("🔔 [Webhook] Endpoint hit - " + new Date().toISOString());

  const signature = getHeader(event, "stripe-signature");
  console.log("🔐 [Webhook] Stripe signature present:", !!signature);

  const rawBody = await readRawBody(event);
  console.log("📦 [Webhook] Raw body length:", rawBody?.length || 0);

  // Sprawdzamy źródło webhooka (StripeCD lub rzeczywisty)
  const webhookSource = getHeader(event, "user-agent") || "";
  const isStripeCLI = webhookSource.toLowerCase().includes("stripecli");
  console.log(
    `🔍 [Webhook] Source: ${
      isStripeCLI ? "Stripe CLI" : "Production"
    } (${webhookSource})`
  );

  // Log all headers for debugging (używając getHeaders, a nie getAll)
  console.log(
    "📋 [Webhook] Headers:",
    JSON.stringify(event.node.req.headers, null, 2)
  );

  console.log(
    `🔍 [Webhook] Source: ${
      isStripeCLI ? "Stripe CLI (local)" : "Stripe (production)"
    }`
  );

  if (!signature || !rawBody) {
    console.error("❌ [Webhook] No signature or body found");
    throw createError({
      statusCode: 400,
      message: "Missing signature or body",
    });
  }

  let stripeEvent;

  try {
    stripeEvent = stripe.webhooks.constructEvent(
      rawBody,
      signature,
      config.stripeWebhookSecret
    );
    console.log(
      `✅ [Webhook] Event verified successfully: ${stripeEvent.type} from ${
        isStripeCLI ? "CLI" : "production"
      }`
    );
  } catch (err) {
    console.error("❌ [Webhook] Signature verification failed:", err);
    throw createError({
      statusCode: 400,
      message: "Webhook signature verification failed",
    });
  }

  // Handle stripe events
  const session = stripeEvent.data.object as Stripe.Checkout.Session;

  // Only handle successful payments
  if (
    stripeEvent.type === "checkout.session.completed" &&
    session.payment_status === "paid"
  ) {
    console.log("💰 [Webhook] Processing completed checkout session:", {
      sessionId: session.id,
      orderNumber: session.metadata?.orderNumber,
      source: isStripeCLI ? "CLI" : "production",
    });

    // Wypisz wszystkie metadane sesji do analizy problemu
    console.log(
      "💰 [Webhook] Session metadata (all):",
      JSON.stringify(session.metadata, null, 2)
    );

    // Specjalnie sprawdź, czy mamy influencerEmail w metadanych
    if (session.metadata?.influencerEmail) {
      console.log(
        `💰 [Webhook] Found influencer email in metadata: ${session.metadata.influencerEmail}`
      );
    } else {
      console.warn(`⚠️ [Webhook] No influencer email found in metadata!`);
    }

    // Sprawdź czy mail już został wysłany (niezależnie od źródła webhooka)
    if (session.metadata?.emailSent === "true") {
      console.log(
        `📧 [Webhook] Email already sent for this session (source: ${
          isStripeCLI ? "CLI" : "production"
        })`
      );
      return { success: true, status: "already_processed" };
    }

    try {
      // W metadanych sesji Stripe powinny znajdować się wszystkie potrzebne informacje
      // o produktach i rabatach, obliczone przez calculateOrderTotals

      // Jeśli nie ma informacji o produktach, a jest to testowy webhook (np. z CLI),
      // używamy przykładowych danych zamiast rzucać błędem
      let parsedProducts;

      if (!session.metadata?.products) {
        console.log(
          `⚠️ [Webhook] Brak informacji o produktach w metadanych. Używanie danych testowych.`
        );

        // Jeśli nie ma informacji o produktach, ale jest influencerEmail, najprawdopodobniej
        // jest to testowy webhook z CLI
        if (session.metadata?.influencerEmail) {
          // Używamy danych testowych z przykładowym produktem
          parsedProducts = [
            {
              id: 1,
              name: "Testowy produkt",
              price: 100,
              quantity: 2,
              lineItemTotalPrice: 200,
              discountAppliedToLineItem: 30,
              lineItemTotalPriceWithDiscount: 170,
            },
          ];
        } else {
          // Jeśli nie ma nawet influencerEmail, to nie jest to test powiadomienia influencera
          throw createError({
            statusCode: 400,
            message: "No product information in session metadata",
          });
        }
      } else {
        // Odczytujemy dane produktów z metadanych
        parsedProducts = JSON.parse(session.metadata.products);
      }

      // Sprawdzamy czy mamy stary czy nowy format danych produktów
      // Nowy format ma skrócone nazwy pól (n, p, q, d, f)
      const isCompressedFormat =
        parsedProducts.length > 0 && "n" in parsedProducts[0];

      // Konwertujemy do pełnego formatu ProductDetail dla łatwiejszego użycia
      const productsWithDetails: ProductDetail[] = parsedProducts.map(
        (product: any) => {
          if (isCompressedFormat) {
            // Konwersja ze skompresowanego formatu
            return {
              id: product.id,
              name: product.n,
              price: product.p,
              quantity: product.q,
              lineItemTotalPrice: product.p * product.q,
              discountAppliedToLineItem: product.d,
              lineItemTotalPriceWithDiscount: product.f,
            };
          } else {
            // Stary format - bez konwersji
            return product as ProductDetail;
          }
        }
      );

      // Odczytujemy wartości rabatów
      const subtotalAmount = parseFloat(
        session.metadata?.subtotalAmount || "0"
      );
      const cartDiscountPercent = parseFloat(
        session.metadata?.cartDiscountPercent || "0"
      );
      const cartDiscountAmount = parseFloat(
        session.metadata?.cartDiscountAmount || "0"
      );
      const codeDiscountPercent = parseFloat(
        session.metadata?.codeDiscountPercent || "0"
      );
      const codeDiscountAmount = parseFloat(
        session.metadata?.codeDiscountAmount || "0"
      );
      const totalDiscountAmount = parseFloat(
        session.metadata?.totalDiscountAmount || "0"
      );
      const finalAmount = parseFloat(session.metadata?.finalAmount || "0");
      const appliedDiscountCode = session.metadata?.appliedDiscountCode || "";

      // Logowanie dla debugowania
      console.log("💰 [Webhook] Order details from session metadata:", {
        subtotalAmount,
        cartDiscountPercent,
        cartDiscountAmount,
        codeDiscountPercent,
        codeDiscountAmount,
        totalDiscountAmount,
        finalAmount,
        appliedDiscountCode,
        numberOfProducts: productsWithDetails.length,
      });

      // Przygotowujemy produkty do szablonu email
      const emailProducts = productsWithDetails.map((product) => {
        return {
          name: product.name || "Produkt",
          quantity: product.quantity,
          price: product.price, // Oryginalna cena jednostkowa
          unitPrice: product.price, // Oryginalna cena jednostkowa
          totalPrice:
            product.lineItemTotalPrice || product.price * product.quantity, // Suma bez rabatu
          priceWithDiscount:
            product.lineItemTotalPriceWithDiscount ||
            product.price * product.quantity -
              (product.discountAppliedToLineItem || 0), // Suma po rabacie
          discountAmount: product.discountAppliedToLineItem || 0, // Kwota rabatu
          image: product.image || "",
        };
      });

      // Przygotowanie danych do wysłania emaila
      const orderDetailsForEmail = {
        orderNumber: session.metadata?.orderNumber,
        customerName: session.metadata?.customerName,
        customerEmail: session.metadata?.customerEmail,
        customerPhone: session.metadata?.customerPhone,
        shippingAddress: {
          street: session.metadata?.shippingStreet,
          houseNumber: session.metadata?.shippingHouseNumber,
          postalCode: session.metadata?.shippingPostalCode,
          city: session.metadata?.shippingCity,
          country: session.metadata?.shippingCountry,
        },
        // Dane finansowe
        subtotalAmount,
        cartDiscountPercent,
        cartDiscountAmount,
        codeDiscountPercent,
        codeDiscountAmount,
        totalDiscountAmount,
        appliedDiscountCode,
        amount: finalAmount,
        // Produkty
        items: emailProducts,
      };

      console.log("📧 [Webhook] Sending order details to email service:", {
        customerEmail: session.metadata?.customerEmail,
        orderNumber: session.metadata?.orderNumber,
        subtotalAmount,
        discounts: {
          cartDiscountPercent,
          cartDiscountAmount,
          codeDiscountPercent,
          codeDiscountAmount,
          totalDiscountAmount,
        },
        finalAmount,
      });

      console.log(
        `📧 [Webhook] Attempting to send order confirmation email to ${session.metadata?.customerEmail}`
      );

      try {
        // Check if we should include an influencer email (from session metadata)
        const influencerEmail = session.metadata?.influencerEmail || null;

        console.log(
          `📧 [Webhook] Influencer email found in metadata: ${
            influencerEmail ? influencerEmail : "none"
          }`
        );

        const emailPayload = {
          customerEmail: session.metadata?.customerEmail,
          influencerEmail: influencerEmail,
          orderDetails: orderDetailsForEmail,
        };

        console.log(
          `📧 [Webhook] Email payload prepared:`,
          JSON.stringify(emailPayload, null, 2)
        );

        // Get the host and construct the base URL
        const headers = event.node.req.headers;
        const protocol = headers["x-forwarded-proto"] || "http";
        const host = headers["x-forwarded-host"] || headers.host;
        const baseUrl = `${protocol}://${host}`;

        const orderConfirmationUrl = `${baseUrl}/api/mail/order-confirmation`;
        console.log(
          `📧 [Webhook] Using full URL for order confirmation: ${orderConfirmationUrl}`
        );

        const emailResponse = await $fetch<{
          success: boolean;
          message?: string;
        }>(orderConfirmationUrl, {
          method: "POST",
          body: emailPayload,
        });

        console.log(`📧 [Webhook] Email API response:`, emailResponse);

        if (!emailResponse.success) {
          console.error(
            `❌ [Webhook] Email API reported failure:`,
            emailResponse
          );
          throw new Error("Failed to send order confirmation email");
        }

        console.log(`✅ [Webhook] Order confirmation email sent successfully`);

        // Jeśli mamy kod influencera, wyślij powiadomienie email
        if (influencerEmail) {
          try {
            console.log(
              `� [Webhook] Sending notification to influencer: ${influencerEmail}`
            );
            console.log(`🔔 [Webhook] Source type: ${isStripeCLI ? "CLI" : "production"}`);
            console.log(`� [Webhook] Session ID: ${session.id}`);

            console.log(`🔔 [Webhook] Host info for influencer notification:`, {
              protocol,
              host,
              baseUrl,
            });

            const influencerNotificationUrl = `${baseUrl}/api/mail/influencer-notification`;
            console.log(
              `📧 [Webhook] Using full URL for influencer notification: ${influencerNotificationUrl}`
            );

            console.log(
              `📧 [Webhook] Preparing influencer notification payload`
            );

            // Przygotuj dane do wysłania
            const notificationPayload = {
              influencerEmail,
              orderDetails: {
                customerName: session.metadata?.customerName,
                customerEmail: session.metadata?.customerEmail,
                orderNumber: session.metadata?.orderNumber,
                appliedDiscountCode:
                  session.metadata?.appliedDiscountCode || "",
                // Pozostałe pola...
              },
            };

            console.log(
              `📧 [Webhook] Influencer notification payload:`,
              JSON.stringify(notificationPayload, null, 2)
            );

            // Poprawiony payload z wszystkimi wymaganymi danymi
            const completePayload = {
              influencerEmail,
              orderDetails: {
                customerName: session.metadata?.customerName,
                customerEmail: session.metadata?.customerEmail,
                orderNumber: session.metadata?.orderNumber,
                appliedDiscountCode:
                  session.metadata?.appliedDiscountCode || "",
                items: emailProducts.map((product) => ({
                  product: {
                    id: 0,
                    name: product.name,
                    price: product.unitPrice,
                    image: product.image || "",
                    description: "",
                  },
                  quantity: product.quantity,
                })),
                subtotalAmount: subtotalAmount,
                finalAmount: finalAmount,
                codeDiscountPercent: codeDiscountPercent,
              },
            };

            console.log(
              `📧 [Webhook] Complete influencer notification payload:`,
              JSON.stringify(completePayload, null, 2)
            );

            // Dodajemy timeout i wyższy poziom debugowania
            const influencerNotificationResult = await $fetch<{
              success: boolean;
              data?: any;
              error?: any;
            }>(influencerNotificationUrl, {
              method: "POST",
              body: completePayload,
              // Dodajemy odpowiednio długi timeout
              timeout: 30000,
              // Zapewniamy, że nagłówki Content-Type są poprawne
              headers: {
                "Content-Type": "application/json",
              },
            });

            console.log(
              `📧 [Webhook] Influencer notification result:`,
              JSON.stringify(influencerNotificationResult, null, 2)
            );

            if (!influencerNotificationResult.success) {
              console.error(
                `❌ [Webhook] Failed to send influencer notification:`,
                JSON.stringify(influencerNotificationResult, null, 2)
              );

              // Dodatkowe szczegóły błędu
              if (influencerNotificationResult.error) {
                console.error(
                  `❌ [Webhook] Influencer notification error details:`,
                  typeof influencerNotificationResult.error === "object"
                    ? JSON.stringify(
                        influencerNotificationResult.error,
                        null,
                        2
                      )
                    : influencerNotificationResult.error
                );
              }

              // Nie blokuj procesu jeśli wysłanie powiadomienia do influencera się nie powiedzie
            } else {
              console.log(
                `✅ [Webhook] Influencer notification sent successfully to: ${influencerEmail}`
              );
            }
          } catch (error: any) {
            console.error(
              `❌ [Webhook] Error sending influencer notification:`,
              error
            );

            // Dodajemy szczegółowe informacje o błędzie
            console.error(
              `❌ [Webhook] Influencer notification error details:`,
              {
                message: error.message || "Unknown error",
                name: error.name,
                stack: error.stack
                  ? error.stack.substring(0, 500)
                  : "no stack trace",
              }
            );

            // Nie przerywamy wykonania, nawet jeśli powiadomienie influencera się nie powiedzie
          }
        }
      } catch (error) {
        console.error(`❌ [Webhook] Error calling email API:`, error);
        throw error;
      }

      // Zawsze oznacz sesję jako obsłużoną
      await stripe.checkout.sessions.update(session.id, {
        metadata: { ...session.metadata, emailSent: "true" },
      });
      console.log(`✅ [Webhook] Session marked as processed`);

      return {
        success: true,
        status: "processed",
        source: isStripeCLI ? "cli" : "production",
      };
    } catch (error) {
      console.error("❌ [Webhook] Order processing failed:", error);
      throw createError({
        statusCode: 500,
        message:
          error instanceof Error ? error.message : "Order processing failed",
      });
    }
  }

  // For other events just acknowledge receipt
  return {
    received: true,
    type: stripeEvent.type,
    status: "unhandled",
    source: isStripeCLI ? "cli" : "production",
  };
});
